[
    {
        "sql": "create or replace TRIGGER TRIGGER1\n  BEFORE UPDATE OF \"NAME\" OR INSERT OR DELETE\n  ON \"TABLE_FOR_TRIGGER\"\n  REFERENCING NEW AS NEW OLD AS OLD\n  FOR EACH ROW ENABLE\n  declare var_tag varchar2(20);  --声明一个变量，存储对dept表执行的操作类\n  begin\n  if inserting then  --当触发事件是insert时\n  var_tag:='插入';   --标识插入操作\n  INSERT INTO TRIGGER_LOG(operation,new_id,new_name) VALUES (var_tag,:NEW.ID,:NEW.NAME);\n  elsif updating then  --当触发事件是update时\n  var_tag:='修改';  --标识修改操作\n  INSERT INTO TRIGGER_LOG VALUES (var_tag,:OLD.ID,:NEW.ID,:OLD.NAME,:NEW.NAME);\n  elsif deleting then  --当触发事件是delete时\n  var_tag:='删除';  --标识删除操作\n  INSERT INTO TRIGGER_LOG(operation,old_id,old_name) VALUES (var_tag,:OLD.ID,:OLD.NAME);\n  end if;\n  END;",
        "delimiter": "/"
    },
    {
        "sql": "\nCREATE OR REPLACE PROCEDURE \"RISKCONFIG\".\"P_ABN_STOCK_E\"\n  (\n   \"I_MARKET_NO\" IN CHAR, \"I_STOCK_CODE\" IN VARCHAR2, \"I_BEGIN_DATE\" IN CHAR, \"I_END_DATE\" IN CHAR, \"I_ABN_BEGIN_DATE\" IN CHAR, \"I_ABN_END_DATE\" IN CHAR, \"I_SS_TYPE\" IN VARCHAR2, \"I_USER_CODE\" IN CHAR, \"I_REMARK\" IN CHAR, \"I_OP_FLAG\" IN VARCHAR2, \"I_PK_ID\" IN VARCHAR2, \"O_RETURN_MSG\" OUT VARCHAR2, \"O_RETURN_CODE\" OUT INTEGER\n  ) IS\n  V_OP_OBJECT  VARCHAR2(50) DEFAULT 'P_ABN_STOCK_E'; -- '操作对象';\n    V_ERROR_MSG  VARCHAR2(200); --返回信息\n    V_ERROR_CODE INTEGER;\n    --===================================================================================\n    -------------------------------------------------------------------------------------\n    --业务变量\n    V_IF_EXIST INTEGER;\n    --===================================================================================\n    -- 业务处理过程\n    --=====================================================================================\n\n    --------------------------业务逻辑开始-----------------------------\n  BEGIN\n    O_RETURN_CODE := 0;\n    O_RETURN_MSG  := '执行成功';\n    --新增\n    IF I_OP_FLAG = '1' THEN\n      SELECT COUNT(1)\n        INTO V_IF_EXIST\n        FROM RISKCONFIG.T_SPECIALSTOCK A\n       WHERE A.SS_TYPE = I_SS_TYPE\n         AND NOT (I_ABN_BEGIN_DATE > A.ABN_END_DATE OR\n              I_ABN_END_DATE < A.ABN_BEGIN_DATE)\n         AND A.MARKET_NO = I_MARKET_NO\n         AND A.STOCK_CODE = I_STOCK_CODE;\n\n       IF V_IF_EXIST > 0 THEN O_RETURN_CODE := -1;\n      O_RETURN_MSG := '该证券的异常波动信息已存在！';\n      RETURN;\n    END IF;\n\n    INSERT INTO RISKCONFIG.T_SPECIALSTOCK\n      (SS_TYPE,\n       MARKET_NO,\n       STOCK_CODE,\n       BEGIN_DATE,\n       END_DATE,\n       SET_OPER,\n       SET_TIME,\n       REMARK,\n       ABN_BEGIN_DATE,\n       ABN_END_DATE)\n      SELECT I_SS_TYPE,\n             I_MARKET_NO,\n             I_STOCK_CODE,\n             I_BEGIN_DATE,\n             I_END_DATE,\n             I_USER_CODE,\n             SYSDATE,\n             I_REMARK,\n             I_ABN_BEGIN_DATE,\n             I_ABN_END_DATE\n        FROM DUAL;\n\n     --插入流水表数据\n    INSERT INTO RISKCONFIG.T_SPECIALSTOCKJOUR(SERIAL_NO,\n                                              OCCUR_DATE,\n                                              OCCUR_TIME,\n                                              OPER_TYPE,\n                                              OPER_CODE,\n                                              MARKET_NO,\n                                              STOCK_CODE,\n                                              BEGIN_DATE,\n                                              END_DATE,\n                                              REMARK,\n                                              SS_TYPE,\n                                              ABN_BEGIN_DATE,\n                                              ABN_END_DATE)\n      SELECT RISKCONFIG.SEQ_SPECIALSTOCKJOUR.NEXTVAL,\n             TO_CHAR(SYSDATE, 'YYYYMMDD'),\n             SUBSTR(TO_CHAR(SYSDATE, 'YYYYMMDD hh24:mi;ss'), 10, 8),\n             '1', --新增\n             I_USER_CODE,\n             I_MARKET_NO,\n             I_STOCK_CODE,\n             I_BEGIN_DATE,\n             I_END_DATE,\n             I_REMARK,\n             I_SS_TYPE,\n             I_ABN_BEGIN_DATE,\n             I_ABN_END_DATE\n        FROM DUAL;\n  END IF;\n\n    --修改\n  IF I_OP_FLAG = '2' THEN\n    UPDATE RISKCONFIG.T_SPECIALSTOCK T\n    SET\n        T.BEGIN_DATE = I_BEGIN_DATE,\n        T.END_DATE = I_END_DATE,\n        T.ABN_BEGIN_DATE = I_ABN_BEGIN_DATE,\n        T.ABN_END_DATE = I_ABN_END_DATE,\n        T.REMARK = I_REMARK\n        WHERE T.PK_ID = I_PK_ID;\n\n\n    --插入流水表数据\n    INSERT INTO RISKCONFIG.T_SPECIALSTOCKJOUR(SERIAL_NO,\n                                              OCCUR_DATE,\n                                              OCCUR_TIME,\n                                              OPER_TYPE,\n                                              OPER_CODE,\n                                              MARKET_NO,\n                                              STOCK_CODE,\n                                              BEGIN_DATE,\n                                              END_DATE,\n                                              REMARK,\n                                              SS_TYPE,\n                                              ABN_BEGIN_DATE,\n                                              ABN_END_DATE)\n      SELECT RISKCONFIG.SEQ_SPECIALSTOCKJOUR.NEXTVAL,\n             TO_CHAR(SYSDATE, 'YYYYMMDD'),\n             SUBSTR(TO_CHAR(SYSDATE, 'YYYYMMDD hh24:mi;ss'), 10, 8),\n             '2', --修改\n             I_USER_CODE,\n             I_MARKET_NO,\n             I_STOCK_CODE,\n             I_BEGIN_DATE,\n             I_END_DATE,\n             I_REMARK,\n             I_SS_TYPE,\n             I_ABN_BEGIN_DATE,\n             I_ABN_END_DATE\n        FROM DUAL;\n\n  END IF;\n  ---删除\n  IF I_OP_FLAG = '3' THEN\n      DELETE FROM RISKCONFIG.T_SPECIALSTOCK T\n     WHERE T.PK_ID = I_PK_ID;\n\n\n    INSERT INTO RISKCONFIG.T_SPECIALSTOCKJOUR(SERIAL_NO,\n                                              OCCUR_DATE,\n                                              OCCUR_TIME,\n                                              OPER_TYPE,\n                                              OPER_CODE,\n                                              MARKET_NO,\n                                              STOCK_CODE,\n                                              BEGIN_DATE,\n                                              END_DATE,\n                                              REMARK,\n                                              SS_TYPE,\n                                              ABN_BEGIN_DATE,\n                                              ABN_END_DATE)\n      SELECT RISKCONFIG.SEQ_SPECIALSTOCKJOUR.NEXTVAL,\n             TO_CHAR(SYSDATE, 'YYYYMMDD'),\n             SUBSTR(TO_CHAR(SYSDATE, 'YYYYMMDD hh24:mi;ss'), 10, 8),\n             '3', --删除\n             I_USER_CODE,\n             T.MARKET_NO,\n             T.STOCK_CODE,\n             T.BEGIN_DATE,\n             T.END_DATE,\n             T.REMARK,\n             T.SS_TYPE,\n             T.ABN_BEGIN_DATE,\n             T.ABN_END_DATE\n        FROM  RISKCONFIG.T_SPECIALSTOCK T\n        WHERE T.PK_ID = I_PK_ID;\n  END IF;\n\n  COMMIT;\n\n    -------------------------------------------------------------\n  O_RETURN_CODE := 0; O_RETURN_MSG := '执行成功';\n  -- ============================================================================\n    -- 错误处理部分\n    -- ============================================================================\n\n  EXCEPTION\n  WHEN OTHERS THEN O_RETURN_CODE := SQLCODE; O_RETURN_MSG := O_RETURN_MSG || SQLERRM; ROLLBACK; V_ERROR_MSG := O_RETURN_MSG; V_ERROR_CODE := O_RETURN_CODE; WOLF.P_ERROR_LOG('admin', -- '操作人';\n  V_OP_OBJECT, -- '操作对象';\n  V_ERROR_CODE, --'错误代码';\n  V_ERROR_MSG, -- '错误信息';\n   '', '', O_RETURN_MSG, --返回信息\n  O_RETURN_CODE --返回值 0 成功必须返回；-1 失败\n  );\n  END;",
        "delimiter": "/"
    },
    {
        "sql": "\ncreate or replace package debug_utils is\n    runtime dbms_debug.runtime_info;\n    function to_error(code binary_integer) return varchar2;\n    function to_reason(code binary_integer) return varchar2;\n    function to_namespace(code binary_integer) return varchar2;\n    procedure print_program(program dbms_debug.program_info);\n    procedure print_runtime(runtime dbms_debug.runtime_info);\n\n    procedure initialize;\n    procedure synchronize;\n    procedure brean_any_return;\n    procedure set_breakpoint(line# binary_integer);\n    procedure disable_breakpoint(num binary_integer);\n    procedure show_breakpoints;\n    procedure print_backtrace;\n    procedure delete_breakpoint(num binary_integer);\n    procedure step_over;\n    procedure step_into;\n    procedure step_any_return;\n    procedure step_abort;\n    procedure get_value(variable_name varchar2, frame# binary_integer);\n    procedure get_runtime_info;\n    procedure get_values;\n\n    procedure get_line_map;\n\n    procedure get_timeout;\n    procedure get_timeout_behaviour;\n    procedure set_timeout(timeout binary_integer);\n  end;",
        "delimiter": "/"
    },
    {
        "sql": "\n  create or replace package body debug_utils is\n    function to_error(code binary_integer) return varchar2 is\n    begin\n      case code\n        when dbms_debug.success then return 'success';\n        when dbms_debug.error_bogus_frame then return 'error_bogus_frame';\n        when dbms_debug.error_no_debug_info then return 'error_no_debug_info';\n        when dbms_debug.error_no_such_object then return 'error_no_such_object';\n        when dbms_debug.error_unknown_type then return 'error_unknown_type';\n        when dbms_debug.error_indexed_table then return 'error_indexed_table';\n        when dbms_debug.error_illegal_index then return 'error_illegal_index';\n        when dbms_debug.error_nullcollection then return 'error_nullcollection';\n        when dbms_debug.error_nullvalue then return 'error_nullvalue';\n        when dbms_debug.error_illegal_value then return 'error_illegal_value';\n        when dbms_debug.error_illegal_null then return 'error_illegal_null';\n        when dbms_debug.error_value_malformed then return 'error_value_malformed';\n        when dbms_debug.error_other then return 'error_other';\n        when dbms_debug.error_name_incomplete then return 'error_name_incomplete';\n        when dbms_debug.error_illegal_line then return 'error_illegal_line';\n        when dbms_debug.error_no_such_breakpt then return 'error_no_such_breakpt';\n        when dbms_debug.error_idle_breakpt then return 'error_idle_breakpt';\n        when dbms_debug.error_stale_breakpt then return 'error_stale_breakpt';\n        when dbms_debug.error_bad_handle then return 'error_bad_handle';\n        when dbms_debug.error_unimplemented then return 'error_unimplemented';\n        when dbms_debug.error_deferred then return 'error_deferred';\n        when dbms_debug.error_exception then return 'error_exception';\n        when dbms_debug.error_communication then return 'error_communication';\n        when dbms_debug.error_timeout then return 'error_timeout';\n        when dbms_debug.error_pbrun_mismatch then return 'error_pbrun_mismatch';\n        when dbms_debug.error_no_rph then return 'error_no_rph';\n        when dbms_debug.error_probe_invalid then return 'error_probe_invalid';\n        when dbms_debug.error_upierr then return 'error_upierr';\n        when dbms_debug.error_noasync then return 'error_noasync';\n        when dbms_debug.error_nologon then return 'error_nologon';\n        when dbms_debug.error_reinit then return 'error_reinit';\n        when dbms_debug.error_unrecognized then return 'error_unrecognized';\n        when dbms_debug.error_synch then return 'error_synch';\n        when dbms_debug.error_incompatible then return 'error_incompatible';\n        else return 'error_unknown';\n      end case;\n      return 'error_unknown';\n    end;\n    function to_reason(code binary_integer) return varchar2 is\n    begin\n      case code\n        when dbms_debug.reason_none then return 'reason_none';\n        when dbms_debug.reason_interpreter_starting then return 'reason_interpreter_starting';\n        when dbms_debug.reason_breakpoint then return 'reason_breakpoint';\n        when dbms_debug .reason_enter then return 'reason_enter';\n        when dbms_debug.reason_return then return 'reason_return';\n        when dbms_debug.reason_finish then return 'reason_finish';\n        when dbms_debug.reason_line then return 'reason_line';\n        when dbms_debug.reason_interrupt then return 'reason_interrupt';\n        when dbms_debug.reason_exception then return 'reason_exception';\n        when dbms_debug.reason_exit then return 'reason_exit';\n        when dbms_debug.reason_handler then return 'reason_handler';\n        when dbms_debug.reason_timeout then return 'reason_timeout';\n        when dbms_debug.reason_instantiate then return 'reason_instantiate';\n        when dbms_debug.reason_abort then return 'reason_abort';\n        when dbms_debug.reason_knl_exit then return 'reason_knl_exit';\n        else return 'reason_unknown';\n      end case;\n      return 'reason_unknown';\n    end;\n    function to_namespace(code binary_integer) return varchar2 is\n    begin\n      case code\n        when dbms_debug.namespace_cursor then return 'namespace_cursor';\n        when dbms_debug.namespace_pkgspec_or_toplevel then return 'namespace_pkgspec_or_toplevel';\n        when dbms_debug.namespace_pkg_body then return 'namespace_pkg_body';\n        when dbms_debug.namespace_trigger then return 'namespace_trigger';\n        when dbms_debug.namespace_none then return 'namespace_none';\n        else return 'namespace_unknown';\n      end case;\n      return 'namespace_unknown';\n    end;\n    procedure print_program(program dbms_debug.program_info) is\n    begin\n      dbms_output.put_line('program_info:');\n      dbms_output.put_line('  namespace = ' || program.namespace || ' ' || to_namespace(program.namespace));\n      dbms_output.put_line('  name = ' || program.name);\n      dbms_output.put_line('  owner = ' || program.owner);\n    end;\n    procedure print_runtime(runtime dbms_debug.runtime_info) is\n    begin\n      dbms_output.put_line('runtime_info:');\n      dbms_output.put_line('  line# = ' || runtime.line#);\n      dbms_output.put_line('  Terminated = ' || runtime.Terminated);\n      dbms_output.put_line('  Breakpoint = ' || runtime.Breakpoint);\n      dbms_output.put_line('  StackDepth = ' || runtime.StackDepth);\n      dbms_output.put_line('  Reason = ' || runtime.Reason || ' ' || to_reason(runtime.Reason));\n      print_program(runtime.program);\n    end;\n    procedure initialize is\n      result varchar2(200);\n    begin\n      result := dbms_debug.initialize();\n      dbms_output.put_line(result);\n    end;\n    procedure synchronize is\n      result binary_integer;\n    begin\n      result := dbms_debug.synchronize(runtime);\n      print_runtime(runtime);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n    end;\n    procedure brean_any_return is\n      result binary_integer;\n    begin\n      result := dbms_debug.continue(runtime, dbms_debug.break_any_return);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n    end;\n    procedure set_breakpoint(line# binary_integer) is\n      result binary_integer;\n      bp_num binary_integer;\n    begin\n      result := dbms_debug.set_breakpoint(runtime.program, line#, bp_num);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n      dbms_output.put_line('bp_num = ' || bp_num);\n    end;\n    procedure disable_breakpoint(num binary_integer) is\n      result binary_integer;\n    begin\n      result := dbms_debug.disable_breakpoint(num);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n    end;\n    procedure show_breakpoints is\n      listing varchar2(4000);\n    begin\n      dbms_debug.show_breakpoints(listing);\n      dbms_output.put_line('breakpoints = ' || listing);\n    end;\n    procedure print_backtrace is\n      listing varchar2(4000);\n    begin\n      dbms_debug.print_backtrace(listing);\n      dbms_output.put_line('backtrace = ' || listing);\n    end;\n    procedure delete_breakpoint(num binary_integer) is\n      result binary_integer;\n    begin\n      result := dbms_debug.delete_breakpoint(num);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n    end;\n    procedure step_over is\n      result binary_integer;\n    begin\n      result := dbms_debug.continue(runtime, dbms_debug.break_next_line);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n      print_runtime(runtime);\n    end;\n    procedure step_into is\n      result binary_integer;\n    begin\n      result := dbms_debug.continue(runtime, dbms_debug.break_any_call);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n      print_runtime(runtime);\n    end;\n    procedure step_any_return is\n      result binary_integer;\n    begin\n      result := dbms_debug.continue(runtime, dbms_debug.break_any_return);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n      print_runtime(runtime);\n    end;\n    procedure step_abort is\n      result binary_integer;\n    begin\n      result := dbms_debug.continue(runtime, dbms_debug.abort_execution);\n      dbms_output.put_line('result = ' || result || to_error(result));\n      print_runtime(runtime);\n    end;\n    procedure get_value(variable_name varchar2, frame# binary_integer) is\n      scalar_value varchar2(2000);\n      result binary_integer;\n    begin\n      result := dbms_debug.get_value(variable_name, frame#, scalar_value);\n      dbms_output.put_line('result = ' || result);\n      dbms_output.put_line('scalar_value = ' || scalar_value);\n    end;\n    procedure get_runtime_info is\n      result binary_integer;\n    begin\n      result := dbms_debug.get_runtime_info(null, runtime);\n      print_runtime(runtime);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n    end;\n    procedure get_values is\n      result binary_integer;\n      scalar_values varchar2(4000);\n    begin\n      -- result := dbms_debug.get_values(scalar_values);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n      dbms_output.put_line('scalar_values = ' || scalar_values);\n    end;\n\n    procedure get_line_map is\n      result binary_integer;\n      maxline binary_integer;\n      number_of_entry_points binary_integer;\n      linemap raw(2000);\n    begin\n      result := dbms_debug.get_line_map(runtime.program, maxline, number_of_entry_points, linemap);\n      dbms_output.put_line('result = ' || result || ' ' || to_error(result));\n      dbms_output.put_line('maxline = ' || maxline);\n      dbms_output.put_line('number_of_entry_points = ' || number_of_entry_points);\n      dbms_output.put_line('linemap = ' || utl_raw.cast_to_varchar2(linemap));\n    end;\n\n    procedure get_timeout is\n    begin\n      dbms_output.put_line(dbms_debug.default_timeout);\n    end;\n\n    procedure get_timeout_behaviour is\n      result binary_integer;\n    begin\n      result := dbms_debug.get_timeout_behaviour();\n      case result\n      when dbms_debug.retry_on_timeout then dbms_output.put_line('retry_on_timeout');\n      when dbms_debug.continue_on_timeout then dbms_output.put_line('continue_on_timeout');\n      when dbms_debug.nodebug_on_timeout then dbms_output.put_line('nodebug_on_timeout');\n      when dbms_debug.abort_on_timeout then dbms_output.put_line('abort_on_timeout');\n      else dbms_output.put_line('unknown timeout behaviour !' || result);\n      end case;\n    end;\n\n    procedure set_timeout(timeout binary_integer) is\n      result binary_integer;\n    begin\n      result := dbms_debug.set_timeout(timeout);\n      dbms_output.put_line('new timeout is ' || result);\n    end;\n  end;",
        "delimiter": "/"
    },
    {
        "sql": "\ndeclare\n      v_pkcount integer;\n      v_pkname varchar2(30);\n      v_tablename varchar2(30);\n  begin\n      v_tablename := 'tbfundliqassetchgfile';\n      select count(1) into v_pkcount from (\n      select au.constraint_name from user_cons_columns cu,user_constraints au\n       where au.table_name = cu.table_name\n         and au.constraint_type = 'P'\n         and au.table_name = upper(v_tablename)\n         and au.constraint_name = cu.constraint_name\n       group by au.constraint_name);\n      if v_pkcount > 0 then\n          select au.constraint_name into v_pkname from user_cons_columns cu,user_constraints au\n           where au.table_name = cu.table_name\n             and au.constraint_type = 'P'\n             and au.table_name = upper(v_tablename)\n             and au.constraint_name = cu.constraint_name\n           group by au.constraint_name;\n          execute immediate 'alter table '||v_tablename||' drop constraint '||v_pkname||' cascade drop index';\n      end if;\n  end;",
        "delimiter": "/"
    },
    {
        "sql": "\ncall proc_droptable('tbfundcustschemaexp')",
        "delimiter": ";"
    },
    {
        "sql": "\ncreate table tbfundcustschemaexp(\n      ta_code                   VARCHAR2(18)         default ' ' not null,\n      prd_code                  VARCHAR2(32)         default ' ' not null,\n      reg_date                  INTEGER              default 0 not null,\n      div_date                  INTEGER              default 0 not null,\n      reinvest_date             INTEGER              default 0 not null,\n      unit_profit               NUMBER(18,8)         default 0.0 not null,\n      project_desc              VARCHAR2(2000)       default ' ' not null,\n      deal_flag                 VARCHAR2(1)          default ' ' not null,\n      tax                       NUMBER(18,2)         default 0.0 not null,\n      manager_code              VARCHAR2(6)          default ' ' not null,\n      remark                    VARCHAR2(1000)       default ' ' not null,\n      constraint pk_fundcustschemaexp primary key (ta_code, prd_code, reg_date, deal_flag)\n  )",
        "delimiter": ";"
    }
]